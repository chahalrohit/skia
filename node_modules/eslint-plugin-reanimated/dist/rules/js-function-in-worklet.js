"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const typescript_1 = require("typescript");
const common_1 = require("./common");
const createRule = experimental_utils_1.ESLintUtils.RuleCreator((name) => {
    return `https://github.com/wcandillon/eslint-plugin-reanimated/blob/master/docs/${name}.md`;
});
const JSFunctionInWorkletMessage = "{{name}} is not a worklet. Use runOnJS instead.";
const isVarInScope = (name, scope) => {
    const { variables } = scope;
    if (variables.find((v) => v.name === name) !== undefined) {
        return true;
    }
    else if (scope.type === "function") {
        return false;
    }
    else if (scope.upper === null) {
        return false;
    }
    return isVarInScope(name, scope.upper);
};
const URI_PREFIX = "/node_modules/";
const getModuleURI = (n) => {
    if (n === undefined) {
        return "";
    }
    else if (typescript_1.isSourceFile(n)) {
        const start = n.fileName.indexOf(URI_PREFIX) + URI_PREFIX.length;
        return n.fileName.substring(start);
    }
    return getModuleURI(n.parent);
};
// eslint-disable-next-line import/no-default-export
exports.default = createRule({
    name: "js-function-in-worklet",
    meta: {
        type: "problem",
        docs: {
            description: "non-worklet functions should be invoked via runOnJS. Use runOnJS() or workletlize instead.",
            recommended: "error",
        },
        fixable: "code",
        schema: [],
        messages: {
            JSFunctionInWorkletMessage,
        },
    },
    defaultOptions: [],
    create: (context) => {
        const { parserServices } = context;
        if (!(parserServices === null || parserServices === void 0 ? void 0 : parserServices.hasFullTypeInformation)) {
            return {};
        }
        const checker = parserServices.program.getTypeChecker();
        const calleeIsWorklet = (tsNode) => {
            const signature = checker.getResolvedSignature(tsNode);
            const decl = signature === null || signature === void 0 ? void 0 : signature.declaration;
            const uri = getModuleURI(decl);
            if (decl !== undefined &&
                (typescript_1.isFunctionTypeNode(decl) || typescript_1.isMethodSignature(decl))) {
                if (uri === "react-native-reanimated/react-native-reanimated.d.ts" ||
                    uri.startsWith("typescript/") ||
                    uri === "@types/node/console.d.ts") {
                    return true;
                }
                const { parent } = decl;
                const tags = typescript_1.getJSDocTags(parent);
                return (tags.filter((tag) => tag.tagName.getText() === common_1.WORKLET).length > 0);
            }
            else if (decl !== undefined &&
                (typescript_1.isFunctionDeclaration(decl) || typescript_1.isArrowFunction(decl))) {
                if (uri.startsWith("typescript/")) {
                    return true;
                }
                if (decl.body && typescript_1.isBlock(decl.body)) {
                    const [statement] = decl.body.statements;
                    if (statement && typescript_1.isExpressionStatement(statement)) {
                        return (statement.expression
                            .getText()
                            .substring(1, common_1.WORKLET.length + 1) === common_1.WORKLET);
                    }
                }
                else {
                    const tags = typescript_1.getJSDocTags(decl);
                    return (tags.filter((tag) => tag.tagName.getText() === common_1.WORKLET).length > 0);
                }
            }
            return false;
        };
        const state = common_1.createState();
        return Object.assign(Object.assign({}, common_1.detectWorklet(state)), { CallExpression: (node) => {
                if (state.callerIsWorklet) {
                    const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                    const { expression } = tsNode;
                    const name = expression.getText();
                    const signature = checker.getResolvedSignature(tsNode);
                    const declaration = signature === null || signature === void 0 ? void 0 : signature.declaration;
                    const inScope = isVarInScope(name, context.getScope());
                    const uri = getModuleURI(declaration);
                    if (inScope) {
                        return;
                    }
                    if (declaration &&
                        typescript_1.isFunctionTypeNode(declaration) &&
                        typescript_1.isFunctionDeclaration(declaration.parent) &&
                        typescript_1.isModuleBlock(declaration.parent.parent) &&
                        declaration.parent.parent.parent.name.getText() === "Animated") {
                        return;
                    }
                    else if (declaration &&
                        typescript_1.isFunctionDeclaration(declaration) &&
                        typescript_1.isModuleBlock(declaration.parent) &&
                        declaration.parent.parent.name.getText() === "Animated") {
                        return;
                    }
                    else if (declaration === undefined) {
                        return;
                    }
                    else if (uri === "react-native-reanimated/react-native-reanimated.d.ts" ||
                        uri.startsWith("typescript/") ||
                        uri === "@types/node/console.d.ts" ||
                        uri.startsWith("@shopify/react-native-skia/lib/typescript/src/skia/types/") ||
                        uri.indexOf("react-native-skia/package/src/skia/types") !== -1) {
                        return;
                    }
                    if (!calleeIsWorklet(tsNode)) {
                        context.report({
                            messageId: "JSFunctionInWorkletMessage",
                            node,
                            data: {
                                name,
                            },
                        });
                    }
                }
            } });
    },
});
